{"version":3,"file":"universal-router-sdk.cjs.production.min.js","sources":["../src/entities/Command.ts","../src/utils/routerCommands.ts","../src/utils/constants.ts","../src/entities/protocols/uniswap.ts","../src/utils/permit2.ts","../src/swapRouter.ts","../src/entities/NFTTrade.ts","../src/entities/protocols/cryptopunk.ts","../src/entities/protocols/foundation.ts","../src/entities/protocols/looksRare.ts","../src/entities/protocols/nft20.ts","../src/entities/protocols/nftx.ts","../src/entities/protocols/seaport.ts","../src/entities/protocols/sudoswap.ts","../src/entities/protocols/x2y2.ts"],"sourcesContent":["import { RoutePlanner } from '../utils/routerCommands'\n\nexport type TradeConfig = {\n  allowRevert: boolean\n}\n\nexport enum RouterTradeType {\n  UniswapTrade = 'UniswapTrade',\n  NFTTrade = 'NFTTrade',\n}\n\n// interface for entities that can be encoded as a Universal Router command\nexport interface Command {\n  tradeType: RouterTradeType\n  encode(planner: RoutePlanner, config: TradeConfig): void\n}\n","import { defaultAbiCoder } from 'ethers/lib/utils'\n\n/**\n * CommandTypes\n * @description Flags that modify a command's execution\n * @enum {number}\n */\nexport enum CommandType {\n  V3_SWAP_EXACT_IN = 0x00,\n  V3_SWAP_EXACT_OUT = 0x01,\n  PERMIT2_TRANSFER_FROM = 0x02,\n  PERMIT2_PERMIT_BATCH = 0x03,\n  SWEEP = 0x04,\n  TRANSFER = 0x05,\n  PAY_PORTION = 0x06,\n\n  V2_SWAP_EXACT_IN = 0x08,\n  V2_SWAP_EXACT_OUT = 0x09,\n  PERMIT = 0x0a,\n  WRAP_ETH = 0x0b,\n  UNWRAP_WETH = 0x0c,\n  PERMIT2_TRANSFER_FROM_BATCH = 0x0d,\n\n  // NFT-related command types\n  SEAPORT = 0x10,\n  LOOKS_RARE_721 = 0x11,\n  NFTX = 0x12,\n  CRYPTOPUNKS = 0x13,\n  LOOKS_RARE_1155 = 0x14,\n  OWNER_CHECK_721 = 0x15,\n  OWNER_CHECK_1155 = 0x16,\n\n  X2Y2_721 = 0x18,\n  SUDOSWAP = 0x19,\n  NFT20 = 0x1a,\n  X2Y2_1155 = 0x1b,\n  FOUNDATION = 0x1c,\n}\n\nconst PERMIT_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce) details, address spender, uint256 sigDeadline)'\n\nconst PERMIT_BATCH_STRUCT =\n  '((address token,uint160 amount,uint48 expiration,uint48 nonce)[] details, address spender, uint256 sigDeadline)'\n\nconst ALLOW_REVERT_FLAG = 0x80\n\nconst REVERTABLE_COMMANDS = new Set<CommandType>([\n  CommandType.SEAPORT,\n  CommandType.NFTX,\n  CommandType.LOOKS_RARE_721,\n  CommandType.LOOKS_RARE_1155,\n  CommandType.X2Y2_721,\n  CommandType.X2Y2_1155,\n  CommandType.FOUNDATION,\n  CommandType.SUDOSWAP,\n  CommandType.NFT20,\n])\n\nconst ABI_DEFINITION: { [key in CommandType]: string[] } = {\n  [CommandType.PERMIT]: [PERMIT_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_PERMIT_BATCH]: [PERMIT_BATCH_STRUCT, 'bytes'],\n  [CommandType.PERMIT2_TRANSFER_FROM]: ['address', 'address', 'uint160'],\n  [CommandType.PERMIT2_TRANSFER_FROM_BATCH]: ['bytes'],\n  [CommandType.TRANSFER]: ['address', 'address', 'uint256'],\n  [CommandType.V3_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V3_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'bytes', 'bool'],\n  [CommandType.V2_SWAP_EXACT_IN]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.V2_SWAP_EXACT_OUT]: ['address', 'uint256', 'uint256', 'address[]', 'bool'],\n  [CommandType.SEAPORT]: ['uint256', 'bytes'],\n  [CommandType.WRAP_ETH]: ['address', 'uint256'],\n  [CommandType.UNWRAP_WETH]: ['address', 'uint256'],\n  [CommandType.SWEEP]: ['address', 'address', 'uint256'],\n  [CommandType.NFTX]: ['uint256', 'bytes'],\n  [CommandType.LOOKS_RARE_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.LOOKS_RARE_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.X2Y2_721]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.X2Y2_1155]: ['uint256', 'bytes', 'address', 'address', 'uint256', 'uint256'],\n  [CommandType.FOUNDATION]: ['uint256', 'bytes', 'address', 'address', 'uint256'],\n  [CommandType.PAY_PORTION]: ['address', 'address', 'uint256'],\n  [CommandType.SUDOSWAP]: ['uint256', 'bytes'],\n  [CommandType.OWNER_CHECK_721]: ['address', 'address', 'uint256'],\n  [CommandType.OWNER_CHECK_1155]: ['address', 'address', 'uint256', 'uint256'],\n  [CommandType.NFT20]: ['uint256', 'bytes'],\n  [CommandType.CRYPTOPUNKS]: ['uint256', 'address', 'uint256'],\n}\n\nexport class RoutePlanner {\n  commands: string\n  inputs: string[]\n\n  constructor() {\n    this.commands = '0x'\n    this.inputs = []\n  }\n\n  addCommand(type: CommandType, parameters: any[], allowRevert = false): void {\n    let command = createCommand(type, parameters)\n    this.inputs.push(command.encodedInput)\n    if (allowRevert) {\n      if (!REVERTABLE_COMMANDS.has(command.type)) {\n        throw new Error(`command type: ${command.type} cannot be allowed to revert`)\n      }\n      command.type = command.type | ALLOW_REVERT_FLAG\n    }\n\n    this.commands = this.commands.concat(command.type.toString(16).padStart(2, '0'))\n  }\n}\n\nexport type RouterCommand = {\n  type: CommandType\n  encodedInput: string\n}\n\nexport function createCommand(type: CommandType, parameters: any[]): RouterCommand {\n  const encodedInput = defaultAbiCoder.encode(ABI_DEFINITION[type], parameters)\n  return { type, encodedInput }\n}\n","import { BigNumber } from 'ethers'\n\nexport const UNIVERSAL_ROUTER_ADDRESS = (chainId: number): string => {\n  switch (chainId) {\n    case 1: //mainnet\n      return '0xEf1c6E67703c7BD7107eed8303Fbe6EC2554BF6B'\n    case 5: // goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 137: // polygon\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 10: // optimism\n      return '0xb555edF5dcF85f42cEeF1f3630a52A108E55A654'\n    case 42161: // arbitrum\n      return '0x4C60051384bd2d3C01bfc845Cf5F4b44bcbE9de5'\n    case 420: // optimism goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 421613: // arbitrum goerli\n      return '0x4648a43B2C14Da09FdF82B161150d3F634f40491'\n    case 42220: // celo\n      return '0xC73d61d192FB994157168Fb56730FdEc64C9Cb8F'\n    default:\n      throw new Error(`Universal Router not deployed on chain ${chainId}`)\n  }\n}\nexport const PERMIT2_ADDRESS = '0x000000000022D473030F116dDEE9F6B43aC78BA3'\n\nexport const CONTRACT_BALANCE = BigNumber.from(2).pow(255)\nexport const ETH_ADDRESS = '0x0000000000000000000000000000000000000000'\n\nexport const SENDER_AS_RECIPIENT = '0x0000000000000000000000000000000000000001'\nexport const ROUTER_AS_RECIPIENT = '0x0000000000000000000000000000000000000002'\n","import JSBI from 'jsbi'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { Trade as V2Trade, Pair } from '@uniswap/v2-sdk'\nimport { Trade as V3Trade, Pool, encodeRouteToPath } from '@uniswap/v3-sdk'\nimport {\n  Trade as RouterTrade,\n  MixedRouteTrade,\n  Protocol,\n  IRoute,\n  RouteV2,\n  RouteV3,\n  MixedRouteSDK,\n  MixedRoute,\n  SwapOptions as RouterSwapOptions,\n  getOutputOfPools,\n  encodeMixedRouteToPath,\n  partitionMixedRouteByProtocol,\n} from '@uniswap/router-sdk'\nimport { Permit2Permit } from '../../utils/permit2'\nimport { Currency, TradeType, CurrencyAmount, Percent } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType, TradeConfig } from '../Command'\nimport { SENDER_AS_RECIPIENT, ROUTER_AS_RECIPIENT, CONTRACT_BALANCE } from '../../utils/constants'\n\n// the existing router permit object doesn't include enough data for permit2\n// so we extend swap options with the permit2 permit\nexport type SwapOptions = Omit<RouterSwapOptions, 'inputTokenPermit'> & {\n  inputTokenPermit?: Permit2Permit\n}\n\nconst REFUND_ETH_PRICE_IMPACT_THRESHOLD = new Percent(JSBI.BigInt(50), JSBI.BigInt(100))\n\ninterface Swap<TInput extends Currency, TOutput extends Currency> {\n  route: IRoute<TInput, TOutput, Pair | Pool>\n  inputAmount: CurrencyAmount<TInput>\n  outputAmount: CurrencyAmount<TOutput>\n}\n\n// Wrapper for uniswap router-sdk trade entity to encode swaps for Universal Router\n// also translates trade objects from previous (v2, v3) SDKs\nexport class UniswapTrade implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.UniswapTrade\n  constructor(public trade: RouterTrade<Currency, Currency, TradeType>, public options: SwapOptions) {}\n\n  encode(planner: RoutePlanner, _config: TradeConfig): void {\n    let payerIsUser = true\n    if (this.trade.inputAmount.currency.isNative) {\n      // TODO: optimize if only one v2 pool we can directly send this to the pool\n      planner.addCommand(CommandType.WRAP_ETH, [\n        ROUTER_AS_RECIPIENT,\n        this.trade.maximumAmountIn(this.options.slippageTolerance).quotient.toString(),\n      ])\n      // since WETH is now owned by the router, the router pays for inputs\n      payerIsUser = false\n    }\n    this.options.recipient = this.options.recipient ?? SENDER_AS_RECIPIENT\n\n    // flag for whether we want to perform slippage check on aggregate output of multiple routes\n    //   1. when there are >2 exact input trades. this is only a heuristic,\n    //      as it's still more gas-expensive even in this case, but has benefits\n    //      in that the reversion probability is lower\n    const performAggregatedSlippageCheck =\n      this.trade.tradeType === TradeType.EXACT_INPUT && this.trade.routes.length > 2\n    const outputIsNative = this.trade.outputAmount.currency.isNative\n    const inputIsNative = this.trade.inputAmount.currency.isNative\n    const routerMustCustody = performAggregatedSlippageCheck || outputIsNative\n\n    for (const swap of this.trade.swaps) {\n      switch (swap.route.protocol) {\n        case Protocol.V2:\n          addV2Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.V3:\n          addV3Swap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        case Protocol.MIXED:\n          addMixedSwap(planner, swap, this.trade.tradeType, this.options, payerIsUser, routerMustCustody)\n          break\n        default:\n          throw new Error('UNSUPPORTED_TRADE_PROTOCOL')\n      }\n    }\n\n    if (routerMustCustody) {\n      if (outputIsNative) {\n        planner.addCommand(CommandType.UNWRAP_WETH, [\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      } else {\n        planner.addCommand(CommandType.SWEEP, [\n          this.trade.outputAmount.currency.wrapped.address,\n          this.options.recipient,\n          this.trade.minimumAmountOut(this.options.slippageTolerance).quotient.toString(),\n        ])\n      }\n    }\n\n    if (inputIsNative && (this.trade.tradeType === TradeType.EXACT_OUTPUT || riskOfPartialFill(this.trade))) {\n      // for exactOutput swaps that take native currency as input\n      // we need to send back the change to the user\n      planner.addCommand(CommandType.UNWRAP_WETH, [this.options.recipient, 0])\n    }\n  }\n}\n\n// encode a uniswap v2 swap\nfunction addV2Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = new V2Trade(\n    route as RouteV2<TInput, TOutput>,\n    tradeType == TradeType.EXACT_INPUT ? inputAmount : outputAmount,\n    tradeType\n  )\n\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n      // if native, we have to unwrap so keep in the router for now\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V2_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      route.path.map((pool) => pool.address),\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a uniswap v3 swap\nfunction addV3Swap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  { route, inputAmount, outputAmount }: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const trade = V3Trade.createUncheckedTrade({\n    route: route as RouteV3<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const path = encodeRouteToPath(route as RouteV3<TInput, TOutput>, trade.tradeType === TradeType.EXACT_OUTPUT)\n  if (tradeType == TradeType.EXACT_INPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  } else if (tradeType == TradeType.EXACT_OUTPUT) {\n    planner.addCommand(CommandType.V3_SWAP_EXACT_OUT, [\n      routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient,\n      trade.minimumAmountOut(options.slippageTolerance).quotient.toString(),\n      trade.maximumAmountIn(options.slippageTolerance).quotient.toString(),\n      path,\n      payerIsUser,\n    ])\n  }\n}\n\n// encode a mixed route swap, i.e. including both v2 and v3 pools\nfunction addMixedSwap<TInput extends Currency, TOutput extends Currency>(\n  planner: RoutePlanner,\n  swap: Swap<TInput, TOutput>,\n  tradeType: TradeType,\n  options: SwapOptions,\n  payerIsUser: boolean,\n  routerMustCustody: boolean\n): void {\n  const { route, inputAmount, outputAmount } = swap\n  const tradeRecipient = routerMustCustody ? ROUTER_AS_RECIPIENT : options.recipient\n\n  // single hop, so it can be reduced to plain v2 or v3 swap logic\n  if (route.pools.length === 1) {\n    if (route.pools[0] instanceof Pool) {\n      return addV3Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else if (route.pools[0] instanceof Pair) {\n      return addV2Swap(planner, swap, tradeType, options, payerIsUser, routerMustCustody)\n    } else {\n      throw new Error('Invalid route type')\n    }\n  }\n\n  const trade = MixedRouteTrade.createUncheckedTrade({\n    route: route as MixedRoute<TInput, TOutput>,\n    inputAmount,\n    outputAmount,\n    tradeType,\n  })\n\n  const amountIn = trade.maximumAmountIn(options.slippageTolerance, inputAmount).quotient.toString()\n  const amountOut = trade.minimumAmountOut(options.slippageTolerance, outputAmount).quotient.toString()\n\n  // logic from\n  // https://github.com/Uniswap/router-sdk/blob/d8eed164e6c79519983844ca8b6a3fc24ebcb8f8/src/swapRouter.ts#L276\n  const sections = partitionMixedRouteByProtocol(route as MixedRoute<TInput, TOutput>)\n  const isLastSectionInRoute = (i: number) => {\n    return i === sections.length - 1\n  }\n\n  let outputToken\n  let inputToken = route.input.wrapped\n\n  for (let i = 0; i < sections.length; i++) {\n    const section = sections[i]\n    /// Now, we get output of this section\n    outputToken = getOutputOfPools(section, inputToken)\n\n    const newRouteOriginal = new MixedRouteSDK(\n      [...section],\n      section[0].token0.equals(inputToken) ? section[0].token0 : section[0].token1,\n      outputToken\n    )\n    const newRoute = new MixedRoute(newRouteOriginal)\n\n    /// Previous output is now input\n    inputToken = outputToken\n\n    const mixedRouteIsAllV3 = (route: MixedRouteSDK<Currency, Currency>) => {\n      return route.pools.every((pool) => pool instanceof Pool)\n    }\n\n    if (mixedRouteIsAllV3(newRoute)) {\n      const path: string = encodeMixedRouteToPath(newRoute)\n\n      planner.addCommand(CommandType.V3_SWAP_EXACT_IN, [\n        // if not last section: send tokens directly to the first v2 pair of the next section\n        // note: because of the partitioning function we can be sure that the next section is v2\n        isLastSectionInRoute(i) ? tradeRecipient : (sections[i + 1][0] as Pair).liquidityToken.address,\n        i == 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOut\n        path, // path\n        payerIsUser && i === 0, // payerIsUser\n      ])\n    } else {\n      planner.addCommand(CommandType.V2_SWAP_EXACT_IN, [\n        isLastSectionInRoute(i) ? tradeRecipient : ROUTER_AS_RECIPIENT, // recipient\n        i === 0 ? amountIn : CONTRACT_BALANCE, // amountIn\n        !isLastSectionInRoute(i) ? 0 : amountOut, // amountOutMin\n        newRoute.path.map((pool) => pool.address), // path\n        payerIsUser && i === 0,\n      ])\n    }\n  }\n}\n\n// if price impact is very high, there's a chance of hitting max/min prices resulting in a partial fill of the swap\nfunction riskOfPartialFill(trade: RouterTrade<Currency, Currency, TradeType>): boolean {\n  return trade.priceImpact.greaterThan(REFUND_ETH_PRICE_IMPACT_THRESHOLD)\n}\n","import { PermitSingle } from '@uniswap/permit2-sdk'\nimport { CommandType, RoutePlanner } from './routerCommands'\n\nexport interface Permit2Permit extends PermitSingle {\n  signature: string\n}\n\nexport function encodePermit(planner: RoutePlanner, permit: Permit2Permit): void {\n  planner.addCommand(CommandType.PERMIT, [permit, permit.signature])\n}\n","import invariant from 'tiny-invariant'\nimport { abi } from '@uniswap/universal-router/artifacts/contracts/UniversalRouter.sol/UniversalRouter.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { MethodParameters } from '@uniswap/v3-sdk'\nimport { Trade as RouterTrade } from '@uniswap/router-sdk'\nimport { Currency, TradeType } from '@uniswap/sdk-core'\nimport { Command, RouterTradeType } from './entities/Command'\nimport { NFTTrade, SupportedProtocolsData } from './entities/NFTTrade'\nimport { UniswapTrade, SwapOptions } from './entities/protocols/uniswap'\nimport { CommandType, RoutePlanner } from './utils/routerCommands'\nimport { encodePermit } from './utils/permit2'\nimport { ROUTER_AS_RECIPIENT, SENDER_AS_RECIPIENT, ETH_ADDRESS } from './utils/constants'\n\nexport type SwapRouterConfig = {\n  sender?: string // address\n  deadline?: BigNumberish\n}\n\ntype SupportedNFTTrade = NFTTrade<SupportedProtocolsData>\n\nexport abstract class SwapRouter {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  public static swapCallParameters(trades: Command[] | Command, config: SwapRouterConfig = {}): MethodParameters {\n    if (!Array.isArray(trades)) trades = [trades]\n\n    const nftTrades = trades.filter((trade, _, []) => trade.hasOwnProperty('market')) as SupportedNFTTrade[]\n    const allowRevert = nftTrades.length == 1 && nftTrades[0].orders.length == 1 ? false : true\n    const planner = new RoutePlanner()\n\n    // track value flow to require the right amount of native value\n    let currentNativeValueInRouter = BigNumber.from(0)\n    let transactionValue = BigNumber.from(0)\n\n    for (const trade of trades) {\n      // is NFTTrade\n      if (trade.tradeType == RouterTradeType.NFTTrade) {\n        const nftTrade = trade as SupportedNFTTrade\n        nftTrade.encode(planner, { allowRevert })\n        const tradePrice = nftTrade.getTotalPrice()\n\n        // send enough native value to contract for NFT purchase\n        if (currentNativeValueInRouter.lt(tradePrice)) {\n          transactionValue = transactionValue.add(tradePrice.sub(currentNativeValueInRouter))\n          currentNativeValueInRouter = BigNumber.from(0)\n        } else {\n          currentNativeValueInRouter = currentNativeValueInRouter.sub(tradePrice)\n        }\n        // is UniswapTrade\n      } else if (trade.tradeType == RouterTradeType.UniswapTrade) {\n        const uniswapTrade = trade as UniswapTrade\n        const inputIsNative = uniswapTrade.trade.inputAmount.currency.isNative\n        const outputIsNative = uniswapTrade.trade.outputAmount.currency.isNative\n        const swapOptions = uniswapTrade.options\n\n        invariant(!(inputIsNative && !!swapOptions.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n        if (!!swapOptions.inputTokenPermit) {\n          encodePermit(planner, swapOptions.inputTokenPermit)\n        }\n\n        if (inputIsNative) {\n          transactionValue = transactionValue.add(\n            BigNumber.from(uniswapTrade.trade.maximumAmountIn(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n        // track amount of native currency in the router\n        if (outputIsNative && swapOptions.recipient == ROUTER_AS_RECIPIENT) {\n          currentNativeValueInRouter = currentNativeValueInRouter.add(\n            BigNumber.from(uniswapTrade.trade.minimumAmountOut(swapOptions.slippageTolerance).quotient.toString())\n          )\n        }\n\n        uniswapTrade.encode(planner, { allowRevert: false })\n      } else {\n        throw 'trade must be of instance: UniswapTrade or NFTTrade'\n      }\n    }\n    // TODO: matches current logic for now, but should eventually only sweep for multiple NFT trades\n    // or NFT trades with potential slippage (i.e. sudo)\n    if (nftTrades.length > 0) planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, transactionValue, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given swap.\n   * @param trades to produce call parameters for\n   */\n  public static swapNFTCallParameters(trades: SupportedNFTTrade[], config: SwapRouterConfig = {}): MethodParameters {\n    let planner = new RoutePlanner()\n    let totalPrice = BigNumber.from(0)\n\n    const allowRevert = trades.length == 1 && trades[0].orders.length == 1 ? false : true\n\n    for (const trade of trades) {\n      trade.encode(planner, { allowRevert })\n      totalPrice = totalPrice.add(trade.getTotalPrice())\n    }\n\n    planner.addCommand(CommandType.SWEEP, [ETH_ADDRESS, SENDER_AS_RECIPIENT, 0])\n    return SwapRouter.encodePlan(planner, totalPrice, config)\n  }\n\n  /**\n   * @deprecated in favor of swapCallParameters. Update before next major version 2.0.0\n   * Produces the on-chain method name to call and the hex encoded parameters to pass as arguments for a given trade.\n   * @param trades to produce call parameters for\n   * @param options options for the call parameters\n   */\n  public static swapERC20CallParameters(\n    trades: RouterTrade<Currency, Currency, TradeType>,\n    options: SwapOptions\n  ): MethodParameters {\n    // TODO: use permit if signature included in swapOptions\n    const planner = new RoutePlanner()\n\n    const trade: UniswapTrade = new UniswapTrade(trades, options)\n\n    const inputCurrency = trade.trade.inputAmount.currency\n    invariant(!(inputCurrency.isNative && !!options.inputTokenPermit), 'NATIVE_INPUT_PERMIT')\n\n    if (options.inputTokenPermit) {\n      encodePermit(planner, options.inputTokenPermit)\n    }\n\n    const nativeCurrencyValue = inputCurrency.isNative\n      ? BigNumber.from(trade.trade.maximumAmountIn(options.slippageTolerance).quotient.toString())\n      : BigNumber.from(0)\n\n    trade.encode(planner, { allowRevert: false })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue, {\n      deadline: options.deadlineOrPreviousBlockhash ? BigNumber.from(options.deadlineOrPreviousBlockhash) : undefined,\n    })\n    return SwapRouter.encodePlan(planner, nativeCurrencyValue)\n  }\n\n  /**\n   * Encodes a planned route into a method name and parameters for the Router contract.\n   * @param planner the planned route\n   * @param nativeCurrencyValue the native currency value of the planned route\n   * @param config the router config\n   */\n  private static encodePlan(\n    planner: RoutePlanner,\n    nativeCurrencyValue: BigNumber,\n    config: SwapRouterConfig = {}\n  ): MethodParameters {\n    const { commands, inputs } = planner\n    const functionSignature = !!config.deadline ? 'execute(bytes,bytes[],uint256)' : 'execute(bytes,bytes[])'\n    const parameters = !!config.deadline ? [commands, inputs, config.deadline] : [commands, inputs]\n    const calldata = SwapRouter.INTERFACE.encodeFunctionData(functionSignature, parameters)\n    return { calldata, value: nativeCurrencyValue.toHexString() }\n  }\n}\n","import invariant from 'tiny-invariant'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { SeaportData } from './protocols/seaport'\nimport { FoundationData } from './protocols/foundation'\nimport { NFTXData } from './protocols/nftx'\nimport { NFT20Data } from './protocols/nft20'\nimport { RoutePlanner } from '../utils/routerCommands'\nimport { Command, RouterTradeType, TradeConfig } from './Command'\nimport { LooksRareData } from './protocols/looksRare'\nimport { SudoswapData } from './protocols/sudoswap'\nimport { CryptopunkData } from './protocols/cryptopunk'\nimport { X2Y2Data } from './protocols/x2y2'\n\nexport type SupportedProtocolsData =\n  | SeaportData\n  | FoundationData\n  | NFTXData\n  | LooksRareData\n  | X2Y2Data\n  | CryptopunkData\n  | NFT20Data\n  | SudoswapData\n\nexport abstract class NFTTrade<T> implements Command {\n  readonly tradeType: RouterTradeType = RouterTradeType.NFTTrade\n  readonly orders: T[]\n  readonly market: Market\n\n  constructor(market: Market, orders: T[]) {\n    invariant(orders.length > 0, 'no buy Items')\n    this.market = market\n    this.orders = orders\n  }\n\n  abstract encode(planner: RoutePlanner, config: TradeConfig): void\n\n  abstract getBuyItems(): BuyItem[]\n\n  abstract getTotalPrice(): BigNumber\n}\n\nexport type BuyItem = {\n  tokenAddress: string\n  tokenId: BigNumberish\n  tokenType: TokenType\n  amount?: BigNumberish // for 1155\n}\n\nexport enum Market {\n  Foundation = 'foundation',\n  LooksRare = 'looksrare',\n  NFT20 = 'nft20',\n  NFTX = 'nftx',\n  Seaport = 'seaport',\n  Sudoswap = 'Sudoswap',\n  Cryptopunks = 'cryptopunks',\n  X2Y2 = 'x2y2',\n}\n\nexport enum TokenType {\n  ERC721 = 'ERC721',\n  ERC1155 = 'ERC1155',\n  Cryptopunk = 'Cryptopunk',\n}\n","import { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type CryptopunkData = {\n  tokenId: BigNumberish\n  recipient: string\n  value: BigNumberish\n}\n\nexport class CryptopunkTrade extends NFTTrade<CryptopunkData> {\n  public static CRYPTOPUNK_ADDRESS: string = '0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb'\n\n  constructor(orders: CryptopunkData[]) {\n    super(Market.Cryptopunks, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      planner.addCommand(CommandType.CRYPTOPUNKS, [item.tokenId, item.recipient, item.value], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: CryptopunkTrade.CRYPTOPUNK_ADDRESS,\n        tokenId: item.tokenId,\n        tokenType: TokenType.Cryptopunk,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Foundation.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type FoundationData = {\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n  referrer: string // address\n}\n\nexport class FoundationTrade extends NFTTrade<FoundationData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: FoundationData[]) {\n    super(Market.Foundation, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = FoundationTrade.INTERFACE.encodeFunctionData('buyV2', [\n        item.tokenAddress,\n        item.tokenId,\n        item.price,\n        item.referrer,\n      ])\n      planner.addCommand(\n        CommandType.FOUNDATION,\n        [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n        config.allowRevert\n      )\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: TokenType.ERC721,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n","import invariant from 'tiny-invariant'\nimport abi from '../../../abis/LooksRare.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type MakerOrder = {\n  collection: string\n  tokenId: BigNumberish\n  isOrderAsk: true\n  signer: string\n  strategy: string\n  currency: string\n  amount: BigNumberish\n  price: BigNumberish\n  minPercentageToAsk: BigNumberish\n  nonce: BigNumberish\n  startTime: BigNumberish\n  endTime: BigNumberish\n  v: BigNumberish\n  r: string\n  s: string\n  params: string\n}\n\nexport type TakerOrder = {\n  minPercentageToAsk: BigNumberish\n  price: BigNumberish\n  taker: string\n  tokenId: BigNumberish\n  isOrderAsk: boolean\n  params: string\n}\n\nexport type LooksRareData = {\n  makerOrder: MakerOrder\n  takerOrder: TakerOrder\n  recipient: string\n  tokenType: TokenType\n}\n\nexport class LooksRareTrade extends NFTTrade<LooksRareData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: LooksRareData[]) {\n    super(Market.LooksRare, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const calldata = LooksRareTrade.INTERFACE.encodeFunctionData('matchAskWithTakerBidUsingETHAndWETH', [\n        item.takerOrder,\n        item.makerOrder,\n      ])\n\n      if (item.tokenType == TokenType.ERC721) {\n        invariant(item.makerOrder.amount == 1, 'ERC721 token amount must be 1')\n        planner.addCommand(\n          CommandType.LOOKS_RARE_721,\n          [item.makerOrder.price, calldata, item.recipient, item.makerOrder.collection, item.makerOrder.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.LOOKS_RARE_1155,\n          [\n            item.makerOrder.price,\n            calldata,\n            item.recipient,\n            item.makerOrder.collection,\n            item.makerOrder.tokenId,\n            item.makerOrder.amount,\n          ],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.makerOrder.collection,\n        tokenId: item.makerOrder.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.makerOrder.price)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFT20.json'\nimport { Interface } from '@ethersproject/abi'\nimport { TradeConfig } from '../Command'\nimport { NFTTrade, Market, TokenType, BuyItem } from '../NFTTrade'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\nexport type NFT20Data = {\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  tokenAmounts: BigNumberish[]\n  recipient: string\n  fee: BigNumberish\n  isV3: boolean\n  value: BigNumberish\n}\n\nexport class NFT20Trade extends NFTTrade<NFT20Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFT20Data[]) {\n    super(Market.NFT20, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFT20Trade.INTERFACE.encodeFunctionData('ethForNft', [\n        order.tokenAddress,\n        order.tokenIds,\n        order.tokenAmounts,\n        order.recipient,\n        order.fee,\n        order.isV3,\n      ])\n      planner.addCommand(CommandType.NFT20, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const pool of this.orders) {\n      for (const tokenId of pool.tokenIds) {\n        buyItems.push({\n          tokenAddress: pool.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/NFTXZap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Ether } from '@uniswap/sdk-core'\n\nexport type NFTXData = {\n  recipient: string\n  vaultAddress: string\n  vaultId: BigNumberish\n  tokenAddress: string\n  tokenIds: BigNumberish[]\n  value: BigNumber\n}\n\nexport class NFTXTrade extends NFTTrade<NFTXData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: NFTXData[]) {\n    super(Market.NFTX, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = NFTXTrade.INTERFACE.encodeFunctionData('buyAndRedeem', [\n        order.vaultId,\n        order.tokenIds.length,\n        order.tokenIds,\n        [Ether.onChain(1).wrapped.address, order.vaultAddress],\n        order.recipient,\n      ])\n      planner.addCommand(CommandType.NFTX, [order.value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const tokenId of order.tokenIds) {\n        buyItems.push({\n          tokenAddress: order.tokenAddress,\n          tokenId: tokenId,\n          tokenType: TokenType.ERC721,\n        })\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.value)\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/Seaport.json'\nimport { BigNumber, BigNumberish } from 'ethers'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\n\nexport type SeaportData = {\n  items: Order[]\n  recipient: string // address\n}\n\nexport type FulfillmentComponent = {\n  orderIndex: BigNumberish\n  itemIndex: BigNumberish\n}\n\nexport type OfferItem = {\n  itemType: BigNumberish // enum\n  token: string // address\n  identifierOrCriteria: BigNumberish\n  startAmount: BigNumberish\n  endAmount: BigNumberish\n}\n\nexport type ConsiderationItem = OfferItem & {\n  recipient: string\n}\n\nexport type Order = {\n  parameters: OrderParameters\n  signature: string\n}\n\ntype OrderParameters = {\n  offerer: string // address,\n  offer: OfferItem[]\n  consideration: ConsiderationItem[]\n  orderType: BigNumberish // enum\n  startTime: BigNumberish\n  endTime: BigNumberish\n  zoneHash: string // bytes32\n  zone: string // address\n  salt: BigNumberish\n  conduitKey: string // bytes32,\n  totalOriginalConsiderationItems: BigNumberish\n}\n\nexport type AdvancedOrder = Order & {\n  numerator: BigNumber // uint120\n  denominator: BigNumber // uint120\n  extraData: string // bytes\n}\n\nexport class SeaportTrade extends NFTTrade<SeaportData> {\n  public static INTERFACE: Interface = new Interface(abi)\n  public static OPENSEA_CONDUIT_KEY: string = '0x0000007b02230091a7ed01230072f7006a004d60a8d4e71d599b8104250f0000'\n\n  constructor(orders: SeaportData[]) {\n    super(Market.Seaport, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      let advancedOrders: AdvancedOrder[] = []\n      let orderFulfillments: FulfillmentComponent[][] = order.items.map((_, index) => [\n        { orderIndex: index, itemIndex: 0 },\n      ])\n      let considerationFulFillments: FulfillmentComponent[][] = this.getConsiderationFulfillments(order.items)\n\n      for (const item of order.items) {\n        const { advancedOrder } = this.getAdvancedOrderParams(item)\n        advancedOrders.push(advancedOrder)\n      }\n\n      let calldata: string\n      if (advancedOrders.length == 1) {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAdvancedOrder', [\n          advancedOrders[0],\n          [],\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n        ])\n      } else {\n        calldata = SeaportTrade.INTERFACE.encodeFunctionData('fulfillAvailableAdvancedOrders', [\n          advancedOrders,\n          [],\n          orderFulfillments,\n          considerationFulFillments,\n          SeaportTrade.OPENSEA_CONDUIT_KEY,\n          order.recipient,\n          100, // TODO: look into making this a better number\n        ])\n      }\n      planner.addCommand(CommandType.SEAPORT, [this.getTotalPrice().toString(), calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        for (const offer of item.parameters.offer) {\n          buyItems.push({\n            tokenAddress: offer.token,\n            tokenId: offer.identifierOrCriteria,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let totalPrice = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const item of order.items) {\n        totalPrice = totalPrice.add(this.calculateValue(item.parameters.consideration))\n      }\n    }\n    return totalPrice\n  }\n\n  private getConsiderationFulfillments(protocolDatas: Order[]): FulfillmentComponent[][] {\n    let considerationFulfillments: FulfillmentComponent[][] = []\n    const considerationRecipients: string[] = []\n\n    for (const i in protocolDatas) {\n      const protocolData = protocolDatas[i]\n\n      for (const j in protocolData.parameters.consideration) {\n        const item = protocolData.parameters.consideration[j]\n\n        if (considerationRecipients.findIndex((x) => x === item.recipient) === -1) {\n          considerationRecipients.push(item.recipient)\n        }\n\n        const recipientIndex = considerationRecipients.findIndex((x) => x === item.recipient)\n\n        if (!considerationFulfillments[recipientIndex]) {\n          considerationFulfillments.push([\n            {\n              orderIndex: i,\n              itemIndex: j,\n            },\n          ])\n        } else {\n          considerationFulfillments[recipientIndex].push({\n            orderIndex: i,\n            itemIndex: j,\n          })\n        }\n      }\n    }\n    return considerationFulfillments\n  }\n\n  private getAdvancedOrderParams(data: Order): { advancedOrder: AdvancedOrder; value: BigNumber } {\n    const advancedOrder = {\n      parameters: data.parameters,\n      numerator: BigNumber.from('1'),\n      denominator: BigNumber.from('1'),\n      signature: data.signature,\n      extraData: '0x00',\n    }\n    const value = this.calculateValue(data.parameters.consideration)\n    return { advancedOrder, value }\n  }\n\n  private calculateValue(considerations: ConsiderationItem[]): BigNumber {\n    return considerations.reduce(\n      (amt: BigNumber, consideration: ConsiderationItem) => amt.add(consideration.startAmount),\n      BigNumber.from(0)\n    )\n  }\n}\n","import abi from '../../../abis/Sudoswap.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype PairSwap = {\n  swapInfo: {\n    pair: string // address\n    nftIds: BigNumberish[]\n  }\n  tokenAddress: string // address\n  maxCost: BigNumberish\n}\n\nexport type SudoswapData = {\n  swaps: PairSwap[]\n  nftRecipient: string\n  ethRecipient: string\n  deadline: BigNumberish\n}\n\nexport class SudoswapTrade extends NFTTrade<SudoswapData> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: SudoswapData[]) {\n    super(Market.Sudoswap, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const order of this.orders) {\n      const calldata = SudoswapTrade.INTERFACE.encodeFunctionData('robustSwapETHForSpecificNFTs', [\n        order.swaps.map((swap) => {\n          return { swapInfo: swap.swapInfo, maxCost: swap.maxCost }\n        }),\n        order.ethRecipient,\n        order.nftRecipient,\n        order.deadline,\n      ])\n      const value = order.swaps.reduce((prevVal, swap) => {\n        return prevVal.add(swap.maxCost)\n      }, BigNumber.from(0))\n      planner.addCommand(CommandType.SUDOSWAP, [value, calldata], config.allowRevert)\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        for (const tokenId of swap.swapInfo.nftIds) {\n          buyItems.push({\n            tokenAddress: swap.tokenAddress,\n            tokenId,\n            tokenType: TokenType.ERC721,\n          })\n        }\n      }\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const order of this.orders) {\n      for (const swap of order.swaps) {\n        total = total.add(swap.maxCost)\n      }\n    }\n    return total\n  }\n}\n","import abi from '../../../abis/X2Y2.json'\nimport { Interface } from '@ethersproject/abi'\nimport { BuyItem, Market, NFTTrade, TokenType } from '../NFTTrade'\nimport { TradeConfig } from '../Command'\nimport { RoutePlanner, CommandType } from '../../utils/routerCommands'\nimport { BigNumber, BigNumberish } from 'ethers'\n\ntype X2Y2PartialData = {\n  signedInput: string\n  recipient: string\n  tokenAddress: string\n  tokenId: BigNumberish\n  price: BigNumberish\n}\n\nexport type X2Y2_721_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC721\n}\n\nexport type X2Y2_1155_Data = X2Y2PartialData & {\n  tokenType: TokenType.ERC1155\n  tokenAmount: BigNumberish\n}\n\nexport type X2Y2Data = X2Y2_721_Data | X2Y2_1155_Data\n\nexport class X2Y2Trade extends NFTTrade<X2Y2Data> {\n  public static INTERFACE: Interface = new Interface(abi)\n\n  constructor(orders: X2Y2Data[]) {\n    super(Market.X2Y2, orders)\n  }\n\n  encode(planner: RoutePlanner, config: TradeConfig): void {\n    for (const item of this.orders) {\n      const functionSelector = X2Y2Trade.INTERFACE.getSighash(X2Y2Trade.INTERFACE.getFunction('run'))\n      const calldata = functionSelector + item.signedInput.slice(2)\n\n      if (item.tokenType == TokenType.ERC721) {\n        planner.addCommand(\n          CommandType.X2Y2_721,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId],\n          config.allowRevert\n        )\n      } else if (item.tokenType == TokenType.ERC1155) {\n        planner.addCommand(\n          CommandType.X2Y2_1155,\n          [item.price, calldata, item.recipient, item.tokenAddress, item.tokenId, item.tokenAmount],\n          config.allowRevert\n        )\n      }\n    }\n  }\n\n  getBuyItems(): BuyItem[] {\n    let buyItems: BuyItem[] = []\n    for (const item of this.orders) {\n      buyItems.push({\n        tokenAddress: item.tokenAddress,\n        tokenId: item.tokenId,\n        tokenType: item.tokenType,\n      })\n    }\n    return buyItems\n  }\n\n  getTotalPrice(): BigNumber {\n    let total = BigNumber.from(0)\n    for (const item of this.orders) {\n      total = total.add(item.price)\n    }\n    return total\n  }\n}\n"],"names":["RouterTradeType","CommandType","REVERTABLE_COMMANDS","Set","SEAPORT","NFTX","LOOKS_RARE_721","LOOKS_RARE_1155","X2Y2_721","X2Y2_1155","FOUNDATION","SUDOSWAP","NFT20","ABI_DEFINITION","PERMIT","PERMIT2_PERMIT_BATCH","PERMIT2_TRANSFER_FROM","PERMIT2_TRANSFER_FROM_BATCH","TRANSFER","V3_SWAP_EXACT_IN","V3_SWAP_EXACT_OUT","V2_SWAP_EXACT_IN","V2_SWAP_EXACT_OUT","WRAP_ETH","UNWRAP_WETH","SWEEP","PAY_PORTION","OWNER_CHECK_721","OWNER_CHECK_1155","CRYPTOPUNKS","RoutePlanner","this","commands","inputs","addCommand","type","parameters","allowRevert","command","encodedInput","defaultAbiCoder","encode","createCommand","push","has","Error","concat","toString","padStart","CONTRACT_BALANCE","BigNumber","from","pow","ETH_ADDRESS","SENDER_AS_RECIPIENT","ROUTER_AS_RECIPIENT","REFUND_ETH_PRICE_IMPACT_THRESHOLD","Percent","JSBI","BigInt","UniswapTrade","trade","options","planner","_config","payerIsUser","inputAmount","currency","isNative","maximumAmountIn","slippageTolerance","quotient","recipient","outputIsNative","outputAmount","inputIsNative","routerMustCustody","tradeType","TradeType","EXACT_INPUT","routes","length","swaps","swap","route","protocol","Protocol","V2","addV2Swap","V3","addV3Swap","MIXED","addMixedSwap","minimumAmountOut","wrapped","address","EXACT_OUTPUT","priceImpact","greaterThan","V2Trade","path","map","pool","V3Trade","createUncheckedTrade","encodeRouteToPath","tradeRecipient","pools","Pool","Pair","outputToken","MixedRouteTrade","amountIn","amountOut","sections","partitionMixedRouteByProtocol","isLastSectionInRoute","i","inputToken","input","section","getOutputOfPools","newRouteOriginal","MixedRouteSDK","token0","equals","token1","newRoute","MixedRoute","every","mixedRouteIsAllV3","encodeMixedRouteToPath","liquidityToken","encodePermit","permit","signature","SwapRouter","swapCallParameters","trades","config","Array","isArray","nftTrades","filter","_","hasOwnProperty","orders","currentNativeValueInRouter","transactionValue","NFTTrade","nftTrade","tradePrice","getTotalPrice","lt","add","sub","uniswapTrade","swapOptions","inputTokenPermit","invariant","encodePlan","swapNFTCallParameters","totalPrice","swapERC20CallParameters","inputCurrency","nativeCurrencyValue","deadline","deadlineOrPreviousBlockhash","undefined","calldata","INTERFACE","encodeFunctionData","value","toHexString","Interface","abi","Market","TokenType","market","CryptopunkTrade","_NFTTrade","Cryptopunks","_inheritsLoose","_proto","item","tokenId","getBuyItems","buyItems","tokenAddress","CRYPTOPUNK_ADDRESS","tokenType","Cryptopunk","total","FoundationTrade","Foundation","price","referrer","ERC721","LooksRareTrade","LooksRare","takerOrder","makerOrder","amount","collection","ERC1155","NFT20Trade","order","tokenIds","tokenAmounts","fee","isV3","NFTXTrade","vaultId","Ether","onChain","vaultAddress","SeaportTrade","Seaport","advancedOrders","orderFulfillments","items","index","orderIndex","itemIndex","considerationFulFillments","getConsiderationFulfillments","getAdvancedOrderParams","advancedOrder","OPENSEA_CONDUIT_KEY","offer","token","identifierOrCriteria","calculateValue","consideration","protocolDatas","considerationFulfillments","considerationRecipients","protocolData","j","findIndex","x","recipientIndex","_loop","data","numerator","denominator","extraData","considerations","reduce","amt","startAmount","SudoswapTrade","Sudoswap","swapInfo","maxCost","ethRecipient","nftRecipient","prevVal","nftIds","X2Y2Trade","X2Y2","getSighash","getFunction","signedInput","slice","tokenAmount","chainId"],"mappings":"8IAMYA,ICCAC,w2CDDAD,EAAAA,0BAAAA,yDAEVA,sBCDF,SAAYC,GACVA,2CACAA,6CACAA,qDACAA,mDACAA,qBACAA,2BACAA,iCAEAA,2CACAA,6CACAA,wBACAA,4BACAA,kCACAA,kEAGAA,0BACAA,wCACAA,oBACAA,kCACAA,0CACAA,0CACAA,4CAEAA,4BACAA,4BACAA,sBACAA,8BACAA,gCA7BF,CAAYA,IAAAA,OAgCZ,IAQMC,EAAsB,IAAIC,IAAiB,CAC/CF,EAAYG,QACZH,EAAYI,KACZJ,EAAYK,eACZL,EAAYM,gBACZN,EAAYO,SACZP,EAAYQ,UACZR,EAAYS,WACZT,EAAYU,SACZV,EAAYW,QAGRC,UACHZ,EAAYa,QAAS,CApBtB,gHAoBsC,WACrCb,EAAYc,sBAAuB,CAlBpC,kHAkB0D,WACzDd,EAAYe,uBAAwB,CAAC,UAAW,UAAW,aAC3Df,EAAYgB,6BAA8B,CAAC,WAC3ChB,EAAYiB,UAAW,CAAC,UAAW,UAAW,aAC9CjB,EAAYkB,kBAAmB,CAAC,UAAW,UAAW,UAAW,QAAS,UAC1ElB,EAAYmB,mBAAoB,CAAC,UAAW,UAAW,UAAW,QAAS,UAC3EnB,EAAYoB,kBAAmB,CAAC,UAAW,UAAW,UAAW,YAAa,UAC9EpB,EAAYqB,mBAAoB,CAAC,UAAW,UAAW,UAAW,YAAa,UAC/ErB,EAAYG,SAAU,CAAC,UAAW,WAClCH,EAAYsB,UAAW,CAAC,UAAW,aACnCtB,EAAYuB,aAAc,CAAC,UAAW,aACtCvB,EAAYwB,OAAQ,CAAC,UAAW,UAAW,aAC3CxB,EAAYI,MAAO,CAAC,UAAW,WAC/BJ,EAAYK,gBAAiB,CAAC,UAAW,QAAS,UAAW,UAAW,aACxEL,EAAYM,iBAAkB,CAAC,UAAW,QAAS,UAAW,UAAW,UAAW,aACpFN,EAAYO,UAAW,CAAC,UAAW,QAAS,UAAW,UAAW,aAClEP,EAAYQ,WAAY,CAAC,UAAW,QAAS,UAAW,UAAW,UAAW,aAC9ER,EAAYS,YAAa,CAAC,UAAW,QAAS,UAAW,UAAW,aACpET,EAAYyB,aAAc,CAAC,UAAW,UAAW,aACjDzB,EAAYU,UAAW,CAAC,UAAW,WACnCV,EAAY0B,iBAAkB,CAAC,UAAW,UAAW,aACrD1B,EAAY2B,kBAAmB,CAAC,UAAW,UAAW,UAAW,aACjE3B,EAAYW,OAAQ,CAAC,UAAW,WAChCX,EAAY4B,aAAc,CAAC,UAAW,UAAW,cAGvCC,aAIX,aACEC,KAAKC,SAAW,KAChBD,KAAKE,OAAS,GAcf,mBAXDC,WAAA,SAAWC,EAAmBC,EAAmBC,YAAAA,IAAAA,GAAc,GAC7D,IAAIC,WAkBsBH,EAAmBC,GAE/C,MAAO,CAAED,KAAAA,EAAMI,aADMC,kBAAgBC,OAAO5B,EAAesB,GAAOC,IAnBlDM,CAAcP,EAAMC,GAElC,GADAL,KAAKE,OAAOU,KAAKL,EAAQC,cACrBF,EAAa,CACf,IAAKnC,EAAoB0C,IAAIN,EAAQH,MACnC,MAAM,IAAIU,uBAAuBP,EAAQH,qCAE3CG,EAAQH,KA1DY,IA0DLG,EAAQH,KAGzBJ,KAAKC,SAAWD,KAAKC,SAASc,OAAOR,EAAQH,KAAKY,SAAS,IAAIC,SAAS,EAAG,YChFlEC,EAAmBC,YAAUC,KAAK,GAAGC,IAAI,KACzCC,EAAc,6CAEdC,EAAsB,6CACtBC,EAAsB,6CCD7BC,EAAoC,IAAIC,UAAQC,EAAKC,OAAO,IAAKD,EAAKC,OAAO,MAUtEC,aAEX,WAAmBC,EAA0DC,GAA1D/B,WAAA8B,EAA0D9B,aAAA+B,EADpE/B,eAA6B/B,wBAAgB4D,aA8DrD,mBA3DDnB,OAAA,SAAOsB,EAAuBC,SACxBC,GAAc,EACdlC,KAAK8B,MAAMK,YAAYC,SAASC,WAElCL,EAAQ7B,WAAWjC,EAAYsB,SAAU,CACvCgC,EACAxB,KAAK8B,MAAMQ,gBAAgBtC,KAAK+B,QAAQQ,mBAAmBC,SAASxB,aAGtEkB,GAAc,GAEhBlC,KAAK+B,QAAQU,mBAAYzC,KAAK+B,QAAQU,aAAalB,EAYnD,IANA,MAEMmB,EAAiB1C,KAAK8B,MAAMa,aAAaP,SAASC,SAClDO,EAAgB5C,KAAK8B,MAAMK,YAAYC,SAASC,SAChDQ,EAHJ7C,KAAK8B,MAAMgB,YAAcC,YAAUC,aAAehD,KAAK8B,MAAMmB,OAAOC,OAAS,GAGnBR,MAEzC1C,KAAK8B,MAAMqB,sBAAO,CAAA,IAA1BC,UACT,OAAQA,EAAKC,MAAMC,UACjB,KAAKC,WAASC,GACZC,EAAUzB,EAASoB,EAAMpD,KAAK8B,MAAMgB,UAAW9C,KAAK+B,QAASG,EAAaW,GAC1E,MACF,KAAKU,WAASG,GACZC,EAAU3B,EAASoB,EAAMpD,KAAK8B,MAAMgB,UAAW9C,KAAK+B,QAASG,EAAaW,GAC1E,MACF,KAAKU,WAASK,MACZC,EAAa7B,EAASoB,EAAMpD,KAAK8B,MAAMgB,UAAW9C,KAAK+B,QAASG,EAAaW,GAC7E,MACF,QACE,MAAM,IAAI/B,MAAM,+BAIlB+B,IACEH,EACFV,EAAQ7B,WAAWjC,EAAYuB,YAAa,CAC1CO,KAAK+B,QAAQU,UACbzC,KAAK8B,MAAMgC,iBAAiB9D,KAAK+B,QAAQQ,mBAAmBC,SAASxB,aAGvEgB,EAAQ7B,WAAWjC,EAAYwB,MAAO,CACpCM,KAAK8B,MAAMa,aAAaP,SAAS2B,QAAQC,QACzChE,KAAK+B,QAAQU,UACbzC,KAAK8B,MAAMgC,iBAAiB9D,KAAK+B,QAAQQ,mBAAmBC,SAASxB,cAKvE4B,IAAkB5C,KAAK8B,MAAMgB,YAAcC,YAAUkB,cAAkCjE,KAAK8B,MAuKrFoC,YAAYC,YAAY1C,KApKjCO,EAAQ7B,WAAWjC,EAAYuB,YAAa,CAACO,KAAK+B,QAAQU,UAAW,UAM3E,SAASgB,EACPzB,IAEAc,EACAf,EACAG,EACAW,OAJEQ,IAAAA,MAMIvB,EAAQ,IAAIsC,QAChBf,EACAP,GAAaC,YAAUC,cARhBb,cAAaQ,aASpBG,GAGEA,GAAaC,YAAUC,YACzBhB,EAAQ7B,WAAWjC,EAAYoB,iBAAkB,CAE/CuD,EAAoBrB,EAAsBO,EAAQU,UAClDX,EAAMQ,gBAAgBP,EAAQQ,mBAAmBC,SAASxB,WAC1Dc,EAAMgC,iBAAiB/B,EAAQQ,mBAAmBC,SAASxB,WAC3DqC,EAAMgB,KAAKC,KAAI,SAACC,GAAI,OAAKA,EAAKP,WAC9B9B,IAEOY,GAAaC,YAAUkB,cAChCjC,EAAQ7B,WAAWjC,EAAYqB,kBAAmB,CAChDsD,EAAoBrB,EAAsBO,EAAQU,UAClDX,EAAMgC,iBAAiB/B,EAAQQ,mBAAmBC,SAASxB,WAC3Dc,EAAMQ,gBAAgBP,EAAQQ,mBAAmBC,SAASxB,WAC1DqC,EAAMgB,KAAKC,KAAI,SAACC,GAAI,OAAKA,EAAKP,WAC9B9B,IAMN,SAASyB,EACP3B,IAEAc,EACAf,EACAG,EACAW,OAJEQ,IAAAA,MAMIvB,EAAQ0C,QAAQC,qBAAqB,CACzCpB,MAAOA,EACPlB,cAROA,YASPQ,eAToBA,aAUpBG,UAAAA,IAGIuB,EAAOK,oBAAkBrB,EAAmCvB,EAAMgB,YAAcC,YAAUkB,cAC5FnB,GAAaC,YAAUC,YACzBhB,EAAQ7B,WAAWjC,EAAYkB,iBAAkB,CAC/CyD,EAAoBrB,EAAsBO,EAAQU,UAClDX,EAAMQ,gBAAgBP,EAAQQ,mBAAmBC,SAASxB,WAC1Dc,EAAMgC,iBAAiB/B,EAAQQ,mBAAmBC,SAASxB,WAC3DqD,EACAnC,IAEOY,GAAaC,YAAUkB,cAChCjC,EAAQ7B,WAAWjC,EAAYmB,kBAAmB,CAChDwD,EAAoBrB,EAAsBO,EAAQU,UAClDX,EAAMgC,iBAAiB/B,EAAQQ,mBAAmBC,SAASxB,WAC3Dc,EAAMQ,gBAAgBP,EAAQQ,mBAAmBC,SAASxB,WAC1DqD,EACAnC,IAMN,SAAS2B,EACP7B,EACAoB,EACAN,EACAf,EACAG,EACAW,GAEA,IAAQQ,EAAqCD,EAArCC,MAAOlB,EAA8BiB,EAA9BjB,YAAaQ,EAAiBS,EAAjBT,aACtBgC,EAAiB9B,EAAoBrB,EAAsBO,EAAQU,UAGzE,GAA2B,IAAvBY,EAAMuB,MAAM1B,OAAc,CAC5B,GAAIG,EAAMuB,MAAM,aAAcC,OAC5B,OAAOlB,EAAU3B,EAASoB,EAAMN,EAAWf,EAASG,EAAaW,GAC5D,GAAIQ,EAAMuB,MAAM,aAAcE,OACnC,OAAOrB,EAAUzB,EAASoB,EAAMN,EAAWf,EAASG,EAAaW,GAEjE,MAAM,IAAI/B,MAAM,sBAwBpB,IApBA,IAiBIiE,EAjBEjD,EAAQkD,kBAAgBP,qBAAqB,CACjDpB,MAAOA,EACPlB,YAAAA,EACAQ,aAAAA,EACAG,UAAAA,IAGImC,EAAWnD,EAAMQ,gBAAgBP,EAAQQ,kBAAmBJ,GAAaK,SAASxB,WAClFkE,EAAYpD,EAAMgC,iBAAiB/B,EAAQQ,kBAAmBI,GAAcH,SAASxB,WAIrFmE,EAAWC,gCAA8B/B,GACzCgC,EAAuB,SAACC,GAC5B,OAAOA,IAAMH,EAASjC,OAAS,GAI7BqC,EAAalC,EAAMmC,MAAMzB,QAEpBuB,EAAI,EAAGA,EAAIH,EAASjC,OAAQoC,IAAK,CACxC,IAAMG,EAAUN,EAASG,GAEzBP,EAAcW,mBAAiBD,EAASF,GAExC,IAAMI,EAAmB,IAAIC,0BACvBH,GACJA,EAAQ,GAAGI,OAAOC,OAAOP,GAAcE,EAAQ,GAAGI,OAASJ,EAAQ,GAAGM,OACtEhB,GAEIiB,EAAW,IAAIC,aAAWN,GAShC,GANAJ,EAAaR,EAEa,SAAC1B,GACzB,OAAOA,EAAMuB,MAAMsB,OAAM,SAAC3B,GAAI,OAAKA,aAAgBM,UAGjDsB,CAAkBH,GAAW,CAC/B,IAAM3B,EAAe+B,yBAAuBJ,GAE5ChE,EAAQ7B,WAAWjC,EAAYkB,iBAAkB,CAG/CiG,EAAqBC,GAAKX,EAAkBQ,EAASG,EAAI,GAAG,GAAYe,eAAerC,QAClF,GAALsB,EAASL,EAAW/D,EACnBmE,EAAqBC,GAASJ,EAAJ,EAC3Bb,EACAnC,GAAqB,IAANoD,SAGjBtD,EAAQ7B,WAAWjC,EAAYoB,iBAAkB,CAC/C+F,EAAqBC,GAAKX,EAAiBnD,EACrC,IAAN8D,EAAUL,EAAW/D,EACpBmE,EAAqBC,GAASJ,EAAJ,EAC3Bc,EAAS3B,KAAKC,KAAI,SAACC,GAAI,OAAKA,EAAKP,WACjC9B,GAAqB,IAANoD,cCzPPgB,EAAatE,EAAuBuE,GAClDvE,EAAQ7B,WAAWjC,EAAYa,OAAQ,CAACwH,EAAQA,EAAOC,gBCanCC,aAAU,cAqI7B,OArI6BA,EAGhBC,mBAAP,SAA0BC,EAA6BC,YAAAA,IAAAA,EAA2B,IAClFC,MAAMC,QAAQH,KAASA,EAAS,CAACA,IAUtC,IARA,MAAMI,EAAYJ,EAAOK,QAAO,SAAClF,EAAOmF,KAAC,OAASnF,EAAMoF,eAAe,aACjE5G,EAAkC,GAApByG,EAAU7D,QAA6C,GAA9B6D,EAAU,GAAGI,OAAOjE,OAC3DlB,EAAU,IAAIjC,EAGhBqH,EAA6BjG,YAAUC,KAAK,GAC5CiG,EAAmBlG,YAAUC,KAAK,OAElBuF,kBAAQ,CAAA,IAAjB7E,UAET,GAAIA,EAAMgB,WAAa7E,wBAAgBqJ,SAAU,CAC/C,IAAMC,EAAWzF,EACjByF,EAAS7G,OAAOsB,EAAS,CAAE1B,YAAAA,IAC3B,IAAMkH,EAAaD,EAASE,gBAGxBL,EAA2BM,GAAGF,IAChCH,EAAmBA,EAAiBM,IAAIH,EAAWI,IAAIR,IACvDA,EAA6BjG,YAAUC,KAAK,IAE5CgG,EAA6BA,EAA2BQ,IAAIJ,OAGzD,CAAA,GAAI1F,EAAMgB,WAAa7E,wBAAgB4D,aA0B5C,KAAM,sDAzBN,IAAMgG,EAAe/F,EACfc,EAAgBiF,EAAa/F,MAAMK,YAAYC,SAASC,SACxDK,EAAiBmF,EAAa/F,MAAMa,aAAaP,SAASC,SAC1DyF,EAAcD,EAAa9F,QAErBa,GAAmBkF,EAAYC,kBAA3CC,MAEMF,EAAYC,kBAChBzB,EAAatE,EAAS8F,EAAYC,kBAGhCnF,IACFyE,EAAmBA,EAAiBM,IAClCxG,YAAUC,KAAKyG,EAAa/F,MAAMQ,gBAAgBwF,EAAYvF,mBAAmBC,SAASxB,cAI1F0B,GAAkBoF,EAAYrF,WAAajB,IAC7C4F,EAA6BA,EAA2BO,IACtDxG,YAAUC,KAAKyG,EAAa/F,MAAMgC,iBAAiBgE,EAAYvF,mBAAmBC,SAASxB,cAI/F6G,EAAanH,OAAOsB,EAAS,CAAE1B,aAAa,KAQhD,OADIyG,EAAU7D,OAAS,GAAGlB,EAAQ7B,WAAWjC,EAAYwB,MAAO,CAAC4B,EAAaC,EAAqB,IAC5FkF,EAAWwB,WAAWjG,EAASqF,EAAkBT,IAG1DH,EAKcyB,sBAAP,SAA6BvB,EAA6BC,YAAAA,IAAAA,EAA2B,IAM1F,IALA,MAAI5E,EAAU,IAAIjC,EACdoI,EAAahH,YAAUC,KAAK,GAE1Bd,EAA+B,GAAjBqG,EAAOzD,QAA0C,GAA3ByD,EAAO,GAAGQ,OAAOjE,WAEvCyD,kBAAQ,CAAA,IAAjB7E,UACTA,EAAMpB,OAAOsB,EAAS,CAAE1B,YAAAA,IACxB6H,EAAaA,EAAWR,IAAI7F,EAAM2F,iBAIpC,OADAzF,EAAQ7B,WAAWjC,EAAYwB,MAAO,CAAC4B,EAAaC,EAAqB,IAClEkF,EAAWwB,WAAWjG,EAASmG,EAAYvB,IAGpDH,EAMc2B,wBAAP,SACLzB,EACA5E,GAGA,IAAMC,EAAU,IAAIjC,EAEd+B,EAAsB,IAAID,EAAa8E,EAAQ5E,GAE/CsG,EAAgBvG,EAAMA,MAAMK,YAAYC,SAClCiG,EAAchG,UAAcN,EAAQgG,kBAAhDC,MAEIjG,EAAQgG,kBACVzB,EAAatE,EAASD,EAAQgG,kBAGhC,IAAMO,EACFnH,YAAUC,KADciH,EAAchG,SACvBP,EAAMA,MAAMQ,gBAAgBP,EAAQQ,mBAAmBC,SAASxB,WAChE,GAGnB,OADAc,EAAMpB,OAAOsB,EAAS,CAAE1B,aAAa,IAC9BmG,EAAWwB,WAAWjG,EAASsG,EAAqB,CACzDC,SAAUxG,EAAQyG,4BAA8BrH,YAAUC,KAAKW,EAAQyG,kCAA+BC,KAK1GhC,EAMewB,WAAP,SACNjG,EACAsG,EACA1B,YAAAA,IAAAA,EAA2B,IAE3B,IAAQ3G,EAAqB+B,EAArB/B,SAAUC,EAAW8B,EAAX9B,OAIlB,MAAO,CAAEwI,SADQjC,EAAWkC,UAAUC,mBAFVhC,EAAO2B,SAAW,iCAAmC,yBAC5D3B,EAAO2B,SAAW,CAACtI,EAAUC,EAAQ0G,EAAO2B,UAAY,CAACtI,EAAUC,IAErE2I,MAAOP,EAAoBQ,qBAnIlCrC,YAAuB,IAAIsC,YAAUC,WC0BzCC,EAWAC,EApCU5B,EAKpB,SAAY6B,EAAgBhC,GAJnBnH,eAA6B/B,wBAAgBqJ,SAK1CH,EAAOjE,OAAS,GAA1B8E,MACAhI,KAAKmJ,OAASA,EACdnJ,KAAKmH,OAASA,IAiBN8B,EAAAA,iBAAAA,4CAEVA,wBACAA,gBACAA,cACAA,oBACAA,sBACAA,4BACAA,eAGUC,EAAAA,oBAAAA,uCAEVA,oBACAA,8BCnDWE,cAGX,WAAYjC,UACVkC,YAAMJ,eAAOK,YAAanC,SAJDoC,OAK1B,kBA0BA,OA1BAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAmB5G,KAAKmH,uBAAQ,CAAA,IAArBsC,UACTzH,EAAQ7B,WAAWjC,EAAY4B,YAAa,CAAC2J,EAAKC,QAASD,EAAKhH,UAAWgH,EAAKZ,OAAQjC,EAAOtG,eAElGkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACP5J,KAAKmH,uBACtByC,EAAShJ,KAAK,CACZiJ,aAAcT,EAAgBU,mBAC9BJ,gBAAcA,QACdK,UAAWb,kBAAUc,aAGzB,OAAOJ,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACRpB,KAAKmH,uBACtB8C,EAAQA,EAAMtC,YAASkB,OAEzB,OAAOoB,MA9B0B3C,GACrB8B,qBAA6B,i1jBCGhCc,cAGX,WAAY/C,UACVkC,YAAMJ,eAAOkB,WAAYhD,SAJAoC,OAK1B,kBAoCA,OApCAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAmB5G,KAAKmH,uBAAQ,CAAA,IAArBsC,UACHf,EAAWwB,EAAgBvB,UAAUC,mBAAmB,QAAS,CACrEa,EAAKI,aACLJ,EAAKC,QACLD,EAAKW,MACLX,EAAKY,WAEPrI,EAAQ7B,WACNjC,EAAYS,WACZ,CAAC8K,EAAKW,MAAO1B,EAAUe,EAAKhH,UAAWgH,EAAKI,aAAcJ,EAAKC,SAC/D9C,EAAOtG,eAGZkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACP5J,KAAKmH,uBAAQ,CAAA,IAArBsC,UACTG,EAAShJ,KAAK,CACZiJ,aAAcJ,EAAKI,aACnBH,QAASD,EAAKC,QACdK,UAAWb,kBAAUoB,SAGzB,OAAOV,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACRpB,KAAKmH,uBACtB8C,EAAQA,EAAMtC,YAASyC,OAEzB,OAAOH,MAxC0B3C,GACrB4C,YAAuB,IAAInB,YAAUC,wnVC2BxCuB,cAGX,WAAYpD,UACVkC,YAAMJ,eAAOuB,UAAWrD,SAJAoC,OAKzB,kBAmDA,OAnDAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAmB5G,KAAKmH,uBAAQ,CAAA,IAArBsC,UACHf,EAAW6B,EAAe5B,UAAUC,mBAAmB,sCAAuC,CAClGa,EAAKgB,WACLhB,EAAKiB,aAGHjB,EAAKM,WAAab,kBAAUoB,QACM,GAA1Bb,EAAKiB,WAAWC,QAA1B3C,MACAhG,EAAQ7B,WACNjC,EAAYK,eACZ,CAACkL,EAAKiB,WAAWN,MAAO1B,EAAUe,EAAKhH,UAAWgH,EAAKiB,WAAWE,WAAYnB,EAAKiB,WAAWhB,SAC9F9C,EAAOtG,cAEAmJ,EAAKM,WAAab,kBAAU2B,SACrC7I,EAAQ7B,WACNjC,EAAYM,gBACZ,CACEiL,EAAKiB,WAAWN,MAChB1B,EACAe,EAAKhH,UACLgH,EAAKiB,WAAWE,WAChBnB,EAAKiB,WAAWhB,QAChBD,EAAKiB,WAAWC,QAElB/D,EAAOtG,eAIdkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACP5J,KAAKmH,uBAAQ,CAAA,IAArBsC,UACTG,EAAShJ,KAAK,CACZiJ,aAAcJ,EAAKiB,WAAWE,WAC9BlB,QAASD,EAAKiB,WAAWhB,QACzBK,UAAWN,EAAKM,YAGpB,OAAOH,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACRpB,KAAKmH,uBACtB8C,EAAQA,EAAMtC,YAAS+C,WAAWN,OAEpC,OAAOH,MAvDyB3C,GACpBiD,YAAuB,IAAIxB,YAAUC,q+EC3BxC8B,cAGX,WAAY3D,UACVkC,YAAMJ,eAAOpK,MAAOsI,SAJAoC,OAKrB,kBAqCA,OArCAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAoB5G,KAAKmH,uBAAQ,CAAA,IAAtB4D,UACHrC,EAAWoC,EAAWnC,UAAUC,mBAAmB,YAAa,CACpEmC,EAAMlB,aACNkB,EAAMC,SACND,EAAME,aACNF,EAAMtI,UACNsI,EAAMG,IACNH,EAAMI,OAERnJ,EAAQ7B,WAAWjC,EAAYW,MAAO,CAACkM,EAAMlC,MAAOH,GAAW9B,EAAOtG,eAEzEkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACP5J,KAAKmH,uBACtB,IAD8B,MAArB5C,cACaA,EAAKyG,yBACzBpB,EAAShJ,KAAK,CACZiJ,aAActF,EAAKsF,aACnBH,gBACAK,UAAWb,kBAAUoB,SAK3B,OAAOV,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACRpB,KAAKmH,uBACtB8C,EAAQA,EAAMtC,YAASkB,OAEzB,OAAOoB,MAzCqB3C,GAChBwD,YAAuB,IAAI/B,YAAUC,+4OCDxCoC,cAGX,WAAYjE,UACVkC,YAAMJ,eAAO3K,KAAM6I,SAJAoC,OAKpB,kBAmCA,OAnCAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAoB5G,KAAKmH,uBAAQ,CAAA,IAAtB4D,UACHrC,EAAW0C,EAAUzC,UAAUC,mBAAmB,eAAgB,CACtEmC,EAAMM,QACNN,EAAMC,SAAS9H,OACf6H,EAAMC,SACN,CAACM,QAAMC,QAAQ,GAAGxH,QAAQC,QAAS+G,EAAMS,cACzCT,EAAMtI,YAERT,EAAQ7B,WAAWjC,EAAYI,KAAM,CAACyM,EAAMlC,MAAOH,GAAW9B,EAAOtG,eAExEkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACN5J,KAAKmH,uBACvB,IAD+B,MAAtB4D,cACaA,EAAMC,yBAC1BpB,EAAShJ,KAAK,CACZiJ,aAAckB,EAAMlB,aACpBH,gBACAK,UAAWb,kBAAUoB,SAI3B,OAAOV,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACRpB,KAAKmH,uBACtB8C,EAAQA,EAAMtC,YAASkB,OAEzB,OAAOoB,MAvCoB3C,GACf8D,YAAuB,IAAIrC,YAAUC,mr6BCoCxCyC,cAIX,WAAYtE,UACVkC,YAAMJ,eAAOyC,QAASvE,SALAoC,OAMvB,kBAmHA,OAnHAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAoB5G,KAAKmH,uBAAQ,CAO/B,IAP+B,MAAtB4D,UACLY,EAAkC,GAClCC,EAA8Cb,EAAMc,MAAMvH,KAAI,SAAC2C,EAAG6E,GAAK,MAAK,CAC9E,CAAEC,WAAYD,EAAOE,UAAW,OAE9BC,EAAsDjM,KAAKkM,6BAA6BnB,EAAMc,WAE/Ed,EAAMc,sBAAO,CAAA,MACJ7L,KAAKmM,gCAC/BR,EAAe/K,OADPwL,eAIV,IAAI1D,EAEFA,EAD2B,GAAzBiD,EAAezI,OACNuI,EAAa9C,UAAUC,mBAAmB,uBAAwB,CAC3E+C,EAAe,GACf,GACAF,EAAaY,oBACbtB,EAAMtI,YAGGgJ,EAAa9C,UAAUC,mBAAmB,iCAAkC,CACrF+C,EACA,GACAC,EACAK,EACAR,EAAaY,oBACbtB,EAAMtI,UACN,MAGJT,EAAQ7B,WAAWjC,EAAYG,QAAS,CAAC2B,KAAKyH,gBAAgBzG,WAAY0H,GAAW9B,EAAOtG,eAE/FkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACN5J,KAAKmH,uBACvB,IAD+B,kBACN0E,sBACvB,IAD8B,kBACLxL,WAAWiM,sBAAO,CAAA,IAAhCA,UACT1C,EAAShJ,KAAK,CACZiJ,aAAcyC,EAAMC,MACpB7C,QAAS4C,EAAME,qBACfzC,UAAWb,kBAAUoB,SAK7B,OAAOV,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIU,EAAahH,YAAUC,KAAK,OACZpB,KAAKmH,uBACvB,IAD+B,kBACN0E,sBACvB1D,EAAaA,EAAWR,IAAI3H,KAAKyM,uBAAoBpM,WAAWqM,gBAGpE,OAAOvE,GACRqB,EAEO0C,6BAAA,SAA6BS,GACnC,IAAIC,EAAsD,GACpDC,EAAoC,GAE1C,IAAK,IAAMvH,KAAKqH,EAAe,CAC7B,IAAMG,EAAeH,EAAcrH,cAExByH,GACT,IAAMtD,EAAOqD,EAAazM,WAAWqM,cAAcK,IAEqB,IAApEF,EAAwBG,WAAU,SAACC,GAAC,OAAKA,IAAMxD,EAAKhH,cACtDoK,EAAwBjM,KAAK6I,EAAKhH,WAGpC,IAAMyK,EAAiBL,EAAwBG,WAAU,SAACC,GAAC,OAAKA,IAAMxD,EAAKhH,aAEtEmK,EAA0BM,GAQ7BN,EAA0BM,GAAgBtM,KAAK,CAC7CmL,WAAYzG,EACZ0G,UAAWe,IATbH,EAA0BhM,KAAK,CAC7B,CACEmL,WAAYzG,EACZ0G,UAAWe,MAbnB,IAAK,IAAMA,KAAKD,EAAazM,WAAWqM,cAAeS,EAA5CJ,GAwBb,OAAOH,GACRpD,EAEO2C,uBAAA,SAAuBiB,GAS7B,MAAO,CAAEhB,cARa,CACpB/L,WAAY+M,EAAK/M,WACjBgN,UAAWlM,YAAUC,KAAK,KAC1BkM,YAAanM,YAAUC,KAAK,KAC5BoF,UAAW4G,EAAK5G,UAChB+G,UAAW,QAGW1E,MADV7I,KAAKyM,eAAeW,EAAK/M,WAAWqM,iBAEnDlD,EAEOiD,eAAA,SAAee,GACrB,OAAOA,EAAeC,QACpB,SAACC,EAAgBhB,GAAgC,OAAKgB,EAAI/F,IAAI+E,EAAciB,eAC5ExM,YAAUC,KAAK,QAvHakG,GAClBmE,YAAuB,IAAI1C,YAAUC,GACrCyC,sBAA8B,mkbCjCjCmC,cAGX,WAAYzG,UACVkC,YAAMJ,eAAO4E,SAAU1G,SAJAoC,OAKxB,kBA2CA,OA3CAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAoB5G,KAAKmH,uBAAQ,CAAA,IAAtB4D,UACHrC,EAAWkF,EAAcjF,UAAUC,mBAAmB,+BAAgC,CAC1FmC,EAAM5H,MAAMmB,KAAI,SAAClB,GACf,MAAO,CAAE0K,SAAU1K,EAAK0K,SAAUC,QAAS3K,EAAK2K,YAElDhD,EAAMiD,aACNjD,EAAMkD,aACNlD,EAAMxC,WAEFM,EAAQkC,EAAM5H,MAAMsK,QAAO,SAACS,EAAS9K,GACzC,OAAO8K,EAAQvG,IAAIvE,EAAK2K,WACvB5M,YAAUC,KAAK,IAClBY,EAAQ7B,WAAWjC,EAAYU,SAAU,CAACiK,EAAOH,GAAW9B,EAAOtG,eAEtEkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACN5J,KAAKmH,uBACvB,IAD+B,kBACNhE,sBACvB,IAD8B,MAArBC,cACaA,EAAK0K,SAASK,uBAClCvE,EAAShJ,KAAK,CACZiJ,aAAczG,EAAKyG,aACnBH,gBACAK,UAAWb,kBAAUoB,SAK7B,OAAOV,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACPpB,KAAKmH,uBACvB,IAD+B,kBACNhE,sBACvB8G,EAAQA,EAAMtC,YAASoG,SAG3B,OAAO9D,MA/CwB3C,GACnBsG,YAAuB,IAAI7E,YAAUC,02WCExCoF,cAGX,WAAYjH,UACVkC,YAAMJ,eAAOoF,KAAMlH,SAJAoC,OAKpB,kBAyCA,OAzCAC,EAED9I,OAAA,SAAOsB,EAAuB4E,GAC5B,cAAmB5G,KAAKmH,uBAAQ,CAAA,IAArBsC,UAEHf,EADmB0F,EAAUzF,UAAU2F,WAAWF,EAAUzF,UAAU4F,YAAY,QACpD9E,EAAK+E,YAAYC,MAAM,GAEvDhF,EAAKM,WAAab,kBAAUoB,OAC9BtI,EAAQ7B,WACNjC,EAAYO,SACZ,CAACgL,EAAKW,MAAO1B,EAAUe,EAAKhH,UAAWgH,EAAKI,aAAcJ,EAAKC,SAC/D9C,EAAOtG,aAEAmJ,EAAKM,WAAab,kBAAU2B,SACrC7I,EAAQ7B,WACNjC,EAAYQ,UACZ,CAAC+K,EAAKW,MAAO1B,EAAUe,EAAKhH,UAAWgH,EAAKI,aAAcJ,EAAKC,QAASD,EAAKiF,aAC7E9H,EAAOtG,eAIdkJ,EAEDG,YAAA,WAEE,IADA,MAAIC,EAAsB,OACP5J,KAAKmH,uBAAQ,CAAA,IAArBsC,UACTG,EAAShJ,KAAK,CACZiJ,aAAcJ,EAAKI,aACnBH,QAASD,EAAKC,QACdK,UAAWN,EAAKM,YAGpB,OAAOH,GACRJ,EAED/B,cAAA,WAEE,IADA,MAAIwC,EAAQ9I,YAAUC,KAAK,OACRpB,KAAKmH,uBACtB8C,EAAQA,EAAMtC,YAASyC,OAEzB,OAAOH,MA7CoB3C,GACf8G,YAAuB,IAAIrF,YAAUC,oKZHtB,gLAtBS,SAAC2F,GACvC,OAAQA,GACN,KAAK,EACH,MAAO,6CACT,KAAK,EACH,MAAO,6CACT,KAAK,IACH,MAAO,6CACT,KAAK,GACH,MAAO,6CACT,KAAK,MACH,MAAO,6CACT,KAAK,IAEL,KAAK,OACH,MAAO,6CACT,KAAK,MACH,MAAO,6CACT,QACE,MAAM,IAAI7N,gDAAgD6N"}